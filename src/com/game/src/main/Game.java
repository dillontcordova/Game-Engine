package com.game.src.main;
import java.awt.Canvas;
import java.awt.Dimension;
import java.awt.event.KeyEvent;
import java.awt.image.BufferStrategy;
import java.io.IOException;
import com.game.src.main.Sprites.ReadSpriteFiles;
import com.game.src.main.Sprites.SpriteSheetGenerator;
import com.game.src.main.controllers.RenderController;
import com.game.src.main.entities.Bullet;
import com.game.src.main.controllers.CalcController;
import com.game.src.main.entities.Player;

public class Game extends Canvas implements Runnable {

	private static final long serialVersionUID = 1L;
	public static final int WIDTH = 320;
	public static final int HEIGHT = WIDTH / 12 * 9;
	public static final int SCALE = 2;
	public final String TITLE = "2D Space Game";
	public final int CALCS_PER_SEC = 60;
	public long numberOfSecs;
	int frames;

	private boolean isShooting = false;
	private boolean running = false;

	private Thread thread;	
	private FrameRender render;
	private Player player;
	private CalcController calcController;
	private RenderController renderController;

	public Game() {
		setPreferredSize(new Dimension(WIDTH * SCALE, HEIGHT * SCALE));
		setMaximumSize(new Dimension(WIDTH * SCALE, HEIGHT * SCALE));
		setMinimumSize(new Dimension(WIDTH * SCALE, HEIGHT * SCALE));
	}

	public void run() {
		init();
		long curTime;
		long frameRegulateTimer;
		numberOfSecs = System.currentTimeMillis();	//	This has been made into a class variable
		frames = 0;									//	As has this

		while(running) {
			frameRegulateTimer = System.currentTimeMillis();
			tick();
			curTime = System.currentTimeMillis();

			printFramesEachSecond(curTime - numberOfSecs);

			regulateFrame(curTime - frameRegulateTimer);
		}
		stop();
	}

	private void printFramesEachSecond(long milliSecsPast) {
		final long oneSecond = 1000;
		frames++;
		if(milliSecsPast > oneSecond) {
			numberOfSecs += oneSecond;
			System.out.println("Fps: " + frames);
			frames = 0;
		}
	}

	private void regulateFrame(long renderTime) {
		long aTick = 1000 / CALCS_PER_SEC;
		if(aTick - renderTime > 0) {
			javaDelay(aTick - renderTime);
		}
	}

	@SuppressWarnings("static-access")
	private void javaDelay(long _delay) {
		try {
			thread.sleep(_delay);
		}
		catch (InterruptedException e) {
			e.printStackTrace();
		}
	}
	
	private void tick() {
		calcController.tick();
	}

	public void init() {
		requestFocus();//so we don't have to click screen

		try {
			ReadSpriteFiles readSpriteFiles = new ReadSpriteFiles("C:\\Game-Engine\\Game-Engine\\res\\SpriteSheets\\spriteSheetInfo.txt");
			SpriteSheetGenerator.spriteSheetCreator(readSpriteFiles.openFile());
		} catch (IOException e) {
			e.printStackTrace();
		}

		calcController = new CalcController();
		renderController = new RenderController();
		player = new Player(200, HEIGHT*SCALE);//TODO: replace
		calcController.createEnemies();

		//TODO: these "adds" will eventually be determined by a file generated by the level editor
		//TODO: maybe move "adds" into init() within the FrameRender Class
//		RenderController.addActorView(new PlayerView(player));

		createBufferStrategy(2);//this creates double buffering //TODO: Move to FrameRender Class
		BufferStrategy bufferStrategy = this.getBufferStrategy(); //TODO: Move to FrameRender Class
		addKeyListener(new KeyInput(this));//has key adapter which creates separate thread for keyboard input
		render = new FrameRender(bufferStrategy, renderController);//rendering is taking place on its own thread FrameRender.java //TODO: Move to FrameRender Class
		render.startThread();
	}
	
	public synchronized void start() {
		if(!running) {
			running = true;
			thread = new Thread(this);//creates tread within current class that looks for run() and all variables that are needed for run()
			thread.setName("calc");
			thread.start();
		}
	}
	
	private synchronized void stop() {
		if(running) {
			running = false;
			try {
				render.stopThread();
				thread.join();
			}
			catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
		System.exit(1);
	}
	
	public void keyPressed(KeyEvent e) {
		int key = e.getKeyCode();
		
		switch(key) {
			case KeyEvent.VK_ESCAPE:
				running = false;
				break;
			case KeyEvent.VK_RIGHT:
				player.setVelX(5);
				break;
			case KeyEvent.VK_LEFT:
				player.setVelX(-5);
				break;
			case KeyEvent.VK_UP:
				player.setVelY(-5);
				break;
			case KeyEvent.VK_DOWN:
				player.setVelY(5);
				break;
			case KeyEvent.VK_SPACE:
				if(!isShooting) {
					isShooting = true;
					if(!Bullet.isMaxBulletsReached() && player.getIsAlive()) {
						calcController.addEntity(new Bullet(player.getX(), player.getY()) );
					}
				}
				break;
		}
	}	
	public void keyReleased(KeyEvent e) {
		int key = e.getKeyCode();
		
		switch(key)
		{
			case KeyEvent.VK_RIGHT:
				player.setVelX(0);
				break;
			case KeyEvent.VK_LEFT:
				player.setVelX(0);
				break;
			case KeyEvent.VK_UP:
				player.setVelY(0);
				break;
			case KeyEvent.VK_DOWN:
				player.setVelY(0);
				break;
			case KeyEvent.VK_SPACE:
				isShooting = false;
				break;
		}
	}
}
