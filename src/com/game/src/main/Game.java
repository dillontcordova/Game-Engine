package com.game.src.main;
import java.awt.Canvas;
import java.awt.Dimension;
import java.awt.image.BufferStrategy;
import java.io.IOException;
import com.game.src.main.Sprites.ReadSpriteFiles;
import com.game.src.main.Sprites.SpriteSheetGenerator;
import com.game.src.main.controllers.RenderController;
import com.game.src.main.controllers.CalcController;
import com.game.src.main.entities.Player;

public class Game extends Canvas implements Runnable {

	public static final int SCALE = 2;
	public static final int WIDTH = 320;
	public static final int HEIGHT = WIDTH / 12 * 9;
	private static final long serialVersionUID = 1L;

	public long numberOfSecs;
	public final int CALCS_PER_SEC = 60;
	public final String TITLE = "2D Space Game";

	private int frames;
	private boolean running = false;

	private Thread thread;
	private FrameRender render;
	private CalcController calcController;
	private RenderController renderController;

	public Game() {
		setPreferredSize(new Dimension(WIDTH * SCALE, HEIGHT * SCALE));
		setMaximumSize(new Dimension(WIDTH * SCALE, HEIGHT * SCALE));
		setMinimumSize(new Dimension(WIDTH * SCALE, HEIGHT * SCALE));
	}

	public void run() {
		init();
		frames = 0;
		long curTime;
		long frameRegulateTimer;
		numberOfSecs = System.currentTimeMillis();

		while(running) {
			frameRegulateTimer = System.currentTimeMillis();
			tick();
			curTime = System.currentTimeMillis();

			printFramesEachSecond(curTime - numberOfSecs);

			regulateFrame(curTime - frameRegulateTimer);
		}
		stop();
	}

	private void printFramesEachSecond(long milliSecsPast) {
		final long oneSecond = 1000;
		frames++;
		if(milliSecsPast > oneSecond) {
			numberOfSecs += oneSecond;
			System.out.println("Fps: " + frames);
			frames = 0;
		}
	}

	private void regulateFrame(long renderTime) {
		long aTick = 1000 / CALCS_PER_SEC;
		if(aTick - renderTime > 0) {
			javaDelay(aTick - renderTime);
		}
	}

	@SuppressWarnings("static-access")
	private void javaDelay(long _delay) {
		try {
			thread.sleep(_delay);
		}
		catch (InterruptedException e) {
			e.printStackTrace();
		}
	}
	
	private void tick() {
		calcController.tick();
	}

	public void init() {
		requestFocus();//so we don't have to click screen

		try {
			ReadSpriteFiles readSpriteFiles = new ReadSpriteFiles("D:\\Repositories\\Java-Game-Engine\\res\\SpriteSheets\\spriteSheetInfo.txt");
			SpriteSheetGenerator.spriteSheetCreator(readSpriteFiles.openFile());
		} catch (IOException e) {
			e.printStackTrace();
		}

		calcController = new CalcController();
		renderController = new RenderController();

		//TODO: these "adds" will eventually be determined by a file generated by the level editor
		//TODO: maybe move "adds" of views into init() within the FrameRender Class
		new Player(200, HEIGHT*SCALE);//TODO: replace
		calcController.createEnemies();

		createBufferStrategy(2);//this creates double buffering //TODO: Move to FrameRender Class
		BufferStrategy bufferStrategy = this.getBufferStrategy(); //TODO: Move to FrameRender Class
		this.addKeyListener(new KeyInput(this));//has key adapter which creates separate thread for keyboard input
		render = new FrameRender(bufferStrategy, renderController);//rendering is taking place on its own thread FrameRender.java //TODO: Move to FrameRender Class
		render.startThread();
	}
	
	public synchronized void start() {
		if(!running) {
			running = true;
			thread = new Thread(this);//creates tread within current class that looks for run() and all variables that are needed for run()
			thread.setName("calc");
			thread.start();
		}
	}
	
	private synchronized void stop() {
		if(running) {
			running = false;
			try {
				render.stopThread();
				thread.join();
			}
			catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
		System.exit(1);
	}
}
